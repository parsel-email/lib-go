<!DOCTYPE html>
<html lang="en">
  <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modifying Data and Using Transactions</title>
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/journal.min.css" rel="stylesheet">
    <link href="/css/site.css" rel="stylesheet">
		<link href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700" rel="stylesheet" type="text/css">

    <link href="/css/prettify.css" type="text/css" rel="stylesheet" />
    <script src="/js/prettify.js" type="text/javascript"></script>
    <script src="/js/lang-go-rich.js" type="text/javascript"></script>
  </head>
  <body onload="prettyPrint()">
    <div class="container">
      <div class="row">
        <div class="span3">
          <div class="leftnav">
  <ul class="nav nav-list">
    
      
      <li class="nav-header ">
        <a href="index.html">Go database/sql tutorial</a>
      </li>
    
      
      <li class=" ">
        <a href="overview.html">Overview</a>
      </li>
    
      
      <li class=" ">
        <a href="importing.html">Importing a Database Driver</a>
      </li>
    
      
      <li class=" ">
        <a href="accessing.html">Accessing the Database</a>
      </li>
    
      
      <li class=" ">
        <a href="retrieving.html">Retrieving Result Sets</a>
      </li>
    
      
      <li class=" active">
        <a href="modifying.html">Modifying Data and Using Transactions</a>
      </li>
    
      
      <li class=" ">
        <a href="prepared.html">Using Prepared Statements</a>
      </li>
    
      
      <li class=" ">
        <a href="errors.html">Handling Errors</a>
      </li>
    
      
      <li class=" ">
        <a href="nulls.html">Working with NULLs</a>
      </li>
    
      
      <li class=" ">
        <a href="varcols.html">Working with Unknown Columns</a>
      </li>
    
      
      <li class=" ">
        <a href="connection-pool.html">The Connection Pool</a>
      </li>
    
      
      <li class=" ">
        <a href="surprises.html">Surprises, Antipatterns and Limitations</a>
      </li>
    
      
      <li class=" ">
        <a href="references.html">Related Reading and Resources</a>
      </li>
    
  </ul>
  <hr />
  <div class="license">
    <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
  </div>
</div>

        </div>

        <div class="span9">
          <div class="page-header">
            <h1>Modifying Data and Using Transactions</h1>
            <a href="https://github.com/VividCortex/go-database-sql-tutorial/edit/gh-pages/modifying.md" class="improve-page btn btn-info" target="_blank">Improve this page</a>
          </div>
          <p>Now we’re ready to see how to modify data and work with transactions. The
distinction might seem artificial if you’re used to programming languages that
use a “statement” object for fetching rows as well as updating data, but in Go,
there’s an important reason for the difference.</p>

<h1 id="statements-that-modify-data">Statements that Modify Data</h1>

<p>Use <code class="language-plaintext highlighter-rouge">Exec()</code>, preferably with a prepared statement, to accomplish an <code class="language-plaintext highlighter-rouge">INSERT</code>,
<code class="language-plaintext highlighter-rouge">UPDATE</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>, or another statement that doesn’t return rows. The following
example shows how to insert a row and inspect metadata about the operation:</p>

<pre class="prettyprint lang-go">
stmt, err := db.Prepare("INSERT INTO users(name) VALUES(?)")
if err != nil {
	log.Fatal(err)
}
res, err := stmt.Exec("Dolly")
if err != nil {
	log.Fatal(err)
}
lastId, err := res.LastInsertId()
if err != nil {
	log.Fatal(err)
}
rowCnt, err := res.RowsAffected()
if err != nil {
	log.Fatal(err)
}
log.Printf("ID = %d, affected = %d\n", lastId, rowCnt)
</pre>

<p>Executing the statement produces a <code class="language-plaintext highlighter-rouge">sql.Result</code> that gives access to statement
metadata: the last inserted ID and the number of rows affected.</p>

<p>What if you don’t care about the result? What if you just want to execute a
statement and check if there were any errors, but ignore the result? Wouldn’t
the following two statements do the same thing?</p>

<pre class="prettyprint lang-go">
_, err := db.Exec("DELETE FROM users")  // OK
_, err := db.Query("DELETE FROM users") // BAD
</pre>

<p>The answer is no. They do <strong>not</strong> do the same thing, and <strong>you should never use
<code class="language-plaintext highlighter-rouge">Query()</code> like this.</strong> The <code class="language-plaintext highlighter-rouge">Query()</code> will return a <code class="language-plaintext highlighter-rouge">sql.Rows</code>, which reserves a
database connection until the <code class="language-plaintext highlighter-rouge">sql.Rows</code> is closed.
Since there might be unread data (e.g. more data rows), the connection can not
be used. In the example above, the connection will <em>never</em> be released again.
The garbage collector will eventually close the underlying <code class="language-plaintext highlighter-rouge">net.Conn</code> for you,
but this might take a long time. Moreover the database/sql package keeps
tracking the connection in its pool, hoping that you release it at some point,
so that the connection can be used again.
This anti-pattern is therefore a good way to run out of resources (too many
connections, for example).</p>

<h1 id="working-with-transactions">Working with Transactions</h1>

<p>In Go, a transaction is essentially an object that reserves a connection to the
datastore. It lets you do all of the operations we’ve seen thus far, but
guarantees that they’ll be executed on the same connection.</p>

<p>You begin a transaction with a call to <code class="language-plaintext highlighter-rouge">db.Begin()</code>, and close it with a
<code class="language-plaintext highlighter-rouge">Commit()</code> or <code class="language-plaintext highlighter-rouge">Rollback()</code> method on the resulting <code class="language-plaintext highlighter-rouge">Tx</code> variable. Under the
covers, the <code class="language-plaintext highlighter-rouge">Tx</code> gets a connection from the pool, and reserves it for use only
with that transaction. The methods on the <code class="language-plaintext highlighter-rouge">Tx</code> map one-for-one to methods you
can call on the database itself, such as <code class="language-plaintext highlighter-rouge">Query()</code> and so forth.</p>

<p>Prepared statements that are created in a transaction are bound exclusively to
that transaction. See <a href="prepared.html">prepared statements</a> for more.</p>

<p>You should not mingle the use of transaction-related functions such as <code class="language-plaintext highlighter-rouge">Begin()</code>
and <code class="language-plaintext highlighter-rouge">Commit()</code> with SQL statements such as <code class="language-plaintext highlighter-rouge">BEGIN</code> and <code class="language-plaintext highlighter-rouge">COMMIT</code> in your SQL
code. Bad things might result:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">Tx</code> objects could remain open, reserving a connection from the pool and not returning it.</li>
  <li>The state of the database could get out of sync with the state of the Go variables representing it.</li>
  <li>You could believe you’re executing queries on a single connection, inside of a transaction, when in reality Go has created several connections for you invisibly and some statements aren’t part of the transaction.</li>
</ul>

<p>While you are working inside a transaction you should be careful not to make
calls to the <code class="language-plaintext highlighter-rouge">db</code> variable. Make all of your calls to the <code class="language-plaintext highlighter-rouge">Tx</code> variable that you
created with <code class="language-plaintext highlighter-rouge">db.Begin()</code>. <code class="language-plaintext highlighter-rouge">db</code> is not in a transaction, only the <code class="language-plaintext highlighter-rouge">Tx</code> object is.
If you make further calls to <code class="language-plaintext highlighter-rouge">db.Exec()</code> or similar, those will happen outside
the scope of your transaction, on other connections.</p>

<p>If you need to work with multiple statements that modify connection state, you
need a <code class="language-plaintext highlighter-rouge">Tx</code> even if you don’t want a transaction per se. For example:</p>

<ul>
  <li>Creating temporary tables, which are only visible to one connection.</li>
  <li>Setting variables, such as MySQL’s <code class="language-plaintext highlighter-rouge">SET @var := somevalue</code> syntax.</li>
  <li>Changing connection options, such as character sets or timeouts.</li>
</ul>

<p>If you need to do any of these things, you need to bind your activity to a
single connection, and the only way to do that in Go is to use a <code class="language-plaintext highlighter-rouge">Tx</code>.</p>

<p><strong>Previous: <a href="retrieving.html">Retrieving Result Sets</a></strong>
<strong>Next: <a href="prepared.html">Using Prepared Statements</a></strong></p>

        </div>
      </div>
    </div>
  </body>
</html>
