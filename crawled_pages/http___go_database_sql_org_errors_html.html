<!DOCTYPE html>
<html lang="en">
  <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handling Errors</title>
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/journal.min.css" rel="stylesheet">
    <link href="/css/site.css" rel="stylesheet">
		<link href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700" rel="stylesheet" type="text/css">

    <link href="/css/prettify.css" type="text/css" rel="stylesheet" />
    <script src="/js/prettify.js" type="text/javascript"></script>
    <script src="/js/lang-go-rich.js" type="text/javascript"></script>
  </head>
  <body onload="prettyPrint()">
    <div class="container">
      <div class="row">
        <div class="span3">
          <div class="leftnav">
  <ul class="nav nav-list">
    
      
      <li class="nav-header ">
        <a href="index.html">Go database/sql tutorial</a>
      </li>
    
      
      <li class=" ">
        <a href="overview.html">Overview</a>
      </li>
    
      
      <li class=" ">
        <a href="importing.html">Importing a Database Driver</a>
      </li>
    
      
      <li class=" ">
        <a href="accessing.html">Accessing the Database</a>
      </li>
    
      
      <li class=" ">
        <a href="retrieving.html">Retrieving Result Sets</a>
      </li>
    
      
      <li class=" ">
        <a href="modifying.html">Modifying Data and Using Transactions</a>
      </li>
    
      
      <li class=" ">
        <a href="prepared.html">Using Prepared Statements</a>
      </li>
    
      
      <li class=" active">
        <a href="errors.html">Handling Errors</a>
      </li>
    
      
      <li class=" ">
        <a href="nulls.html">Working with NULLs</a>
      </li>
    
      
      <li class=" ">
        <a href="varcols.html">Working with Unknown Columns</a>
      </li>
    
      
      <li class=" ">
        <a href="connection-pool.html">The Connection Pool</a>
      </li>
    
      
      <li class=" ">
        <a href="surprises.html">Surprises, Antipatterns and Limitations</a>
      </li>
    
      
      <li class=" ">
        <a href="references.html">Related Reading and Resources</a>
      </li>
    
  </ul>
  <hr />
  <div class="license">
    <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
  </div>
</div>

        </div>

        <div class="span9">
          <div class="page-header">
            <h1>Handling Errors</h1>
            <a href="https://github.com/VividCortex/go-database-sql-tutorial/edit/gh-pages/errors.md" class="improve-page btn btn-info" target="_blank">Improve this page</a>
          </div>
          <p>Almost all operations with <code class="language-plaintext highlighter-rouge">database/sql</code> types return an error as the last
value. You should always check these errors, never ignore them.</p>

<p>There are a few places where error behavior is special-case, or there’s
something additional you might need to know.</p>

<h1 id="errors-from-iterating-resultsets">Errors From Iterating Resultsets</h1>

<p>Consider the following code:</p>

<pre class="prettyprint lang-go">
for rows.Next() {
	// ...
}
if err = rows.Err(); err != nil {
	// handle the error here
}
</pre>

<p>The error from <code class="language-plaintext highlighter-rouge">rows.Err()</code> could be the result of a variety of errors in the
<code class="language-plaintext highlighter-rouge">rows.Next()</code> loop. The loop
might exit for some reason other than finishing the loop normally, so you always
need to check whether the loop terminated normally or not. An abnormal
termination automatically calls <code class="language-plaintext highlighter-rouge">rows.Close()</code>, although it’s harmless to call it
multiple times.</p>

<h1 id="errors-from-closing-resultsets">Errors From Closing Resultsets</h1>

<p>You should always explicitly close a <code class="language-plaintext highlighter-rouge">sql.Rows</code> if you exit the loop
prematurely, as previously mentioned. It’s auto-closed if the loop exits
normally or through an error, but you might mistakenly do this:</p>

<pre class="prettyprint lang-go">
for rows.Next() {
	// ...
	break; // whoops, rows is not closed! memory leak...
}
// do the usual "if err = rows.Err()" [omitted here]...
// it's always safe to [re?]close here:
if err = rows.Close(); err != nil {
	// but what should we do if there's an error?
	log.Println(err)
}
</pre>

<p>The error returned by <code class="language-plaintext highlighter-rouge">rows.Close()</code> is the only exception to the general rule
that it’s best to capture and check for errors in all database operations. If
<code class="language-plaintext highlighter-rouge">rows.Close()</code> returns an error, it’s unclear what you should do.
Logging the error message or panicing might be the only sensible thing,
and if that’s not sensible, then perhaps you should just ignore the error.</p>

<h1 id="errors-from-queryrow">Errors From QueryRow()</h1>

<p>Consider the following code to fetch a single row:</p>

<pre class="prettyprint lang-go">
var name string
err = db.QueryRow("select name from users where id = ?", 1).Scan(&amp;name)
if err != nil {
	log.Fatal(err)
}
fmt.Println(name)
</pre>

<p>What if there was no user with <code class="language-plaintext highlighter-rouge">id = 1</code>? Then there would be no row in the
result, and <code class="language-plaintext highlighter-rouge">.Scan()</code> would not scan a value into <code class="language-plaintext highlighter-rouge">name</code>. What happens then?</p>

<p>Go defines a special error constant, called <code class="language-plaintext highlighter-rouge">sql.ErrNoRows</code>, which is returned
from <code class="language-plaintext highlighter-rouge">QueryRow()</code> when the result is empty. This needs to be handled as a
special case in most circumstances. An empty result is often not considered an
error by application code, and if you don’t check whether an error is this
special constant, you’ll cause application-code errors you didn’t expect.</p>

<p>Errors from the query are deferred until <code class="language-plaintext highlighter-rouge">Scan()</code> is called, and then are
returned from that. The above code is better written like this instead:</p>

<pre class="prettyprint lang-go">
var name string
err = db.QueryRow("select name from users where id = ?", 1).Scan(&amp;name)
if err != nil {
	if err == sql.ErrNoRows {
		// there were no rows, but otherwise no error occurred
	} else {
		log.Fatal(err)
	}
}
fmt.Println(name)
</pre>

<p>One might ask why an empty result set is considered an error. There’s nothing
erroneous about an empty set. The reason is that the <code class="language-plaintext highlighter-rouge">QueryRow()</code> method needs
to use this special-case in order to let the caller distinguish whether
<code class="language-plaintext highlighter-rouge">QueryRow()</code> in fact found a row; without it, <code class="language-plaintext highlighter-rouge">Scan()</code> wouldn’t do anything and
you might not realize that your variable didn’t get any value from the database
after all.</p>

<p>You should only run into this error when you’re using <code class="language-plaintext highlighter-rouge">QueryRow()</code>. If you
encounter this error elsewhere, you’re doing something wrong.</p>

<h1 id="identifying-specific-database-errors">Identifying Specific Database Errors</h1>

<p>It can be tempting to write code like the following:</p>

<pre class="prettyprint lang-go">
rows, err := db.Query("SELECT someval FROM sometable")
// err contains:
// ERROR 1045 (28000): Access denied for user 'foo'@'::1' (using password: NO)
if strings.Contains(err.Error(), "Access denied") {
	// Handle the permission-denied error
}
</pre>

<p>This is not the best way to do it, though. For example, the string value might
vary depending on what language the server uses to send error messages.  It’s
much better to compare error numbers to identify what a specific error is.</p>

<p>The mechanism to do this varies between drivers, however, because this isn’t
part of <code class="language-plaintext highlighter-rouge">database/sql</code> itself. In the MySQL driver that this tutorial focuses
on, you could write the following code:</p>

<pre class="prettyprint lang-go">
if driverErr, ok := err.(*mysql.MySQLError); ok { // Now the error number is accessible directly
	if driverErr.Number == 1045 {
		// Handle the permission-denied error
	}
}
</pre>

<p>Again, the <code class="language-plaintext highlighter-rouge">MySQLError</code> type here is provided by this specific driver, and the
<code class="language-plaintext highlighter-rouge">.Number</code> field may differ between drivers. The value of the number, however,
is taken from MySQL’s error message, and is therefore database specific, not
driver specific.</p>

<p>This code is still ugly. Comparing to 1045, a magic number, is a code smell.
Some drivers (though not the MySQL one, for reasons that are off-topic here)
provide a list of error identifiers. The Postgres <code class="language-plaintext highlighter-rouge">pq</code> driver does, for example, in
<a href="https://github.com/lib/pq/blob/master/error.go">error.go</a>. And there’s an
external package of <a href="https://github.com/VividCortex/mysqlerr">MySQL error numbers maintained by
VividCortex</a>. Using such a list, the
above code is better written thus:</p>

<pre class="prettyprint lang-go">
if driverErr, ok := err.(*mysql.MySQLError); ok {
	if driverErr.Number == mysqlerr.ER_ACCESS_DENIED_ERROR {
		// Handle the permission-denied error
	}
}
</pre>

<h1 id="handling-connection-errors">Handling Connection Errors</h1>

<p>What if your connection to the database is dropped, killed, or has an error?</p>

<p>You don’t need to implement any logic to retry failed statements when this
happens. As part of the <a href="connection-pool.html">connection pooling</a> in
<code class="language-plaintext highlighter-rouge">database/sql</code>, handling failed connections is built-in. If you execute a query
or other statement and the underlying connection has a failure, Go will reopen a
new connection (or just get another from the connection pool) and retry, up to
10 times.</p>

<p>There can be some unintended consequences, however. Some types of errors may be
retried when other error conditions happen. This might also be driver-specific.
One example that has occurred with the MySQL driver is that using <code class="language-plaintext highlighter-rouge">KILL</code> to
cancel an undesired statement (such as a long-running query) results in the
statement being retried up to 10 times.</p>

<p><strong>Previous: <a href="prepared.html">Using Prepared Statements</a></strong>
<strong>Next: <a href="nulls.html">Working with NULLs</a></strong></p>

        </div>
      </div>
    </div>
  </body>
</html>
